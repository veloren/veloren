use super::*;
use crate::{
    Land,
    site::generation::{PrimitiveTransform, spiral_staircase},
    util::{CARDINALS, DIAGONALS, RandomField, Sampler, within_distance},
};
use common::{
    generation::SpecialEntity,
    terrain::{BlockKind, SpriteKind},
};
use rand::prelude::*;
use std::{f32::consts::PI, sync::Arc};
use vek::{ops::Lerp, *};

/// Represents house data generated by the `generate()` method
pub struct AirshipDock {
    /// Approximate altitude of the door tile
    pub(crate) alt: i32,
    rotation: f32,
    pub door_tile: Vec2<i32>,
    pub center: Vec2<i32>,
    base: i32,
    upper_alt: i32,
    min_foundation_alt: i32,
    surface_colors: Vec<Rgb<u8>>,
    sub_surface_colors: Vec<Rgb<u8>>,
    pub docking_positions: Vec<Vec3<i32>>,
    pub door_dir: Vec2<i32>,
    campfire_pos: Vec3<i32>,
}

impl AirshipDock {
    pub fn generate(
        land: &Land,
        index: IndexRef,
        _rng: &mut impl Rng,
        site: &Site,
        door_tile: Vec2<i32>,
        door_dir: Vec2<i32>,
        tile_aabr: Aabr<i32>,
    ) -> Self {
        // dock is 30 blocks in radius
        // airships are 37 blocks wide.
        // distance from the center to the outside edge of the airship when docked is 67
        // blocks. The area covered by all four airships is a square 134 blocks
        // on a side.

        let door_tile_pos: Vec2<i32> = site.tile_center_wpos(door_tile);
        let bounds = Aabr {
            min: site.tile_wpos(tile_aabr.min),
            max: site.tile_wpos(tile_aabr.max),
        };
        let center = bounds.center();
        // door_tile_pos and tile_aabr are relative to the site origin.
        // bounds and center are in world blocks.

        // The bounds will be 54 blocks square.
        // That's enough for the dock structure itself minus 1/2 an overlap tile on each
        // side. In city towns with low buildings, this allows airships to dock
        // above the buildings.

        // For airship clearance however, the terrain must be sampled across the entire
        // area where an airship might be docked (134 blocks square), plus some
        // extra to allow for when the airship overshoots the dock on descent.
        let halfspan = 66;
        let min_clearance_x = center.x - halfspan;
        let max_clearance_x = center.x + halfspan;
        let min_clearance_y = center.y - halfspan;
        let max_clearance_y = center.y + halfspan;
        let mut max_surface_alt = i32::MIN;
        let mut surface_colors = vec![];
        let mut sub_surface_colors = vec![];
        // Since this range is from -66 to +66 (132 blocks), sampling every 22 blocks
        // will give exactly 7 samples along each axis (because 132 is divisible by 22)
        // as long as the range is inclusive.
        for x in (min_clearance_x..=max_clearance_x).step_by(22) {
            for y in (min_clearance_y..=max_clearance_y).step_by(22) {
                let pos = Vec2::new(x, y);
                let alt = land.get_surface_alt_approx(pos) as i32;
                if alt > max_surface_alt {
                    max_surface_alt = alt;
                }
            }
        }

        // The foundation and possibly pedestal that the tower sits on
        // is approximately 40 blocks square. The bottom of the foundation area
        // must be at the lowest surface altitude in that area.
        let min_foundation_x = center.x - 20;
        let max_foundation_x = center.x + 20;
        let min_foundation_y = center.y - 20;
        let max_foundation_y = center.y + 20;
        let mut max_foundation_alt = i32::MIN;
        let mut min_foundation_alt = i32::MAX;
        let color_component_to_u8 =
            |compf32: f32| -> u8 { (compf32.clamp(0.0, 1.0) * 255.0).floor() as u8 };

        // Since this range is from -20 to +20 (40 blocks), sampling every 10 blocks
        // will give exactly 5 samples along each axis (because 40 is divisible by 10)
        // as long as the range is inclusive.
        for x in (min_foundation_x..=max_foundation_x).step_by(10) {
            for y in (min_foundation_y..=max_foundation_y).step_by(10) {
                let pos = Vec2::new(x, y);
                let alt = land.get_surface_alt_approx(pos) as i32;
                if alt > max_foundation_alt {
                    max_foundation_alt = alt;
                }
                if alt < min_foundation_alt {
                    min_foundation_alt = alt;
                }
                if let Some(sample) = land.column_sample(pos, index) {
                    surface_colors.push(sample.surface_color.map(color_component_to_u8));
                    sub_surface_colors.push(sample.sub_surface_color.map(color_component_to_u8));
                }
            }
        }
        // When docked, the bottom of the airship will be at the platform height.
        // The platform height must be at or above max_surface_alt.
        // The platform height must be at least 36 blocks above the base of the tower
        // (the tower must be at least 36 blocks tall).
        // The base of the tower must be at or above max_foundation_alt.
        let min_base = max_surface_alt - 36;
        let base = min_base.max(max_foundation_alt);

        let upper_alt = base + 28;
        // negate the rotation angle because Mat3::rotation_z is CCW, but atan2 returns
        // PI/2 for (1,0) which is a CW rotation.
        let rotation = -f32::atan2(door_dir.x as f32, door_dir.y as f32);
        let mut docking_positions = vec![];
        for dir in CARDINALS {
            let pos = (center + dir * 31).with_z(upper_alt + 9);
            docking_positions.push(pos);
        }
        let campfire_dir = Mat2::rotation_z(-PI / 4.0) * door_dir.map(|i| i as f32);
        let campfire_pos = (center.map(|i| i as f32) + (campfire_dir * 11.0))
            .map(|f| f.round() as i32)
            .with_z(upper_alt + 9);
        Self {
            door_tile: door_tile_pos,
            alt: base,
            rotation,
            center,
            base,
            upper_alt,
            min_foundation_alt,
            surface_colors,
            sub_surface_colors,
            docking_positions,
            door_dir,
            campfire_pos,
        }
    }

    pub fn spawn_rules(&self, wpos: Vec2<i32>) -> SpawnRules {
        SpawnRules {
            trees: {
                // dock is 5 tiles = 30 blocks in radius
                // airships are 37 blocks wide.
                // Some trees are 20 to 30 blocks in radius.
                // Leave extra space for tree width.
                // Don't allow trees within 30 + 37 + 30 = 97 blocks of the dock center
                const AIRSHIP_MIN_TREE_DIST2: i32 = 100;
                !within_distance(wpos, self.center, AIRSHIP_MIN_TREE_DIST2)
            },
            waypoints: false,
            ..SpawnRules::default()
        }
    }
}

impl Structure for AirshipDock {
    #[cfg(feature = "use-dyn-lib")]
    const UPDATE_FN: &'static [u8] = b"render_airshipdock\0";

    #[cfg_attr(feature = "be-dyn-lib", unsafe(export_name = "render_airshipdock"))]
    fn render_inner(&self, _site: &Site, _land: &Land, painter: &Painter) {
        let brick = Fill::Brick(BlockKind::Rock, Rgb::new(80, 75, 85), 24);
        let wood = Fill::Brick(BlockKind::Rock, Rgb::new(45, 28, 21), 24);
        let woodalt = Fill::Brick(BlockKind::Rock, Rgb::new(30, 22, 15), 24);
        let grass = {
            let surface_colors = self.surface_colors.clone();
            let num_colors = surface_colors.len() as u32;
            Fill::Sampling(Arc::new(move |wpos| {
                let index = if num_colors > 0 {
                    (RandomField::new(0).get(wpos) % num_colors) as usize
                } else {
                    0usize
                };
                Some(Block::new(
                    BlockKind::Earth,
                    surface_colors
                        .get(index)
                        .cloned()
                        .unwrap_or(Rgb::new(55, 25, 8)),
                ))
            }))
        };
        let dirt = {
            let sub_surface_colors = self.sub_surface_colors.clone();
            let num_colors = sub_surface_colors.len() as u32;
            let avg_color = if num_colors > 0 {
                let mut r_total: f32 = 0.0;
                let mut g_total: f32 = 0.0;
                let mut b_total: f32 = 0.0;
                for color in &sub_surface_colors {
                    r_total += color.r as f32;
                    g_total += color.g as f32;
                    b_total += color.b as f32;
                }
                Rgb::new(
                    r_total / num_colors as f32,
                    g_total / num_colors as f32,
                    b_total / num_colors as f32,
                )
            } else {
                Rgb::new(55.0, 25.0, 8.0)
            };
            Fill::Sampling(Arc::new(move |wpos| {
                let color = if num_colors > 0 {
                    sub_surface_colors
                        .get((RandomField::new(0).get(wpos) % num_colors) as usize)
                        .copied()
                        .unwrap_or(Rgb::new(55, 25, 8))
                        .map(|u| u as f32)
                } else {
                    avg_color
                };
                // the final color is a lerp from avg_color 25% to 75% of the way to the
                // randomly selected color index.
                let lerp_factor = (RandomField::new(1).get(wpos) % 51 + 25) as f32 / 100.0;
                let block_color = Rgb::new(
                    Lerp::lerp(avg_color.r, color.r, lerp_factor),
                    Lerp::lerp(avg_color.g, color.g, lerp_factor),
                    Lerp::lerp(avg_color.b, color.b, lerp_factor),
                )
                .map(|f| f.clamp(0.0, 255.0) as u8);
                Some(Block::new(BlockKind::Earth, block_color))
            }))
        };
        let base = self.base;
        let center = self.center;
        let upper_alt = self.upper_alt;
        let min_foundation_alt = self.min_foundation_alt;

        // Build everything that is outside the column that
        // forms the main structure before the tower so that
        // painting the main column will carve a hole inside them.

        //bracing
        painter
            .cylinder_with_radius(center.with_z(upper_alt - 3), 7.0, 1.0)
            .fill(wood.clone());
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 6), 7.0, 1.0)
            .fill(wood.clone());
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 7), 8.0, 1.0)
            .fill(wood.clone());

        // platform
        painter
            .superquadric(
                Aabb {
                    min: (center - 8000).with_z(upper_alt + 7),
                    max: (center + 8000).with_z(upper_alt + 11),
                },
                0.3,
            )
            .intersect(painter.aabb(Aabb {
                min: (center - 31).with_z(upper_alt + 7),
                max: (center + 31).with_z(upper_alt + 11),
            }))
            .fill(woodalt.clone());
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 8), 19.0, 2.0)
            .fill(woodalt.clone());
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 8), 18.0, 2.0)
            .fill(wood.clone());
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 9), 18.0, 1.0)
            .clear();
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 30, center.y - 2).with_z(upper_alt + 8),
                max: Vec2::new(center.x + 30, center.y + 2).with_z(upper_alt + 10),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 30, center.y - 2).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 30, center.y + 2).with_z(upper_alt + 10),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 2, center.y - 30).with_z(upper_alt + 8),
                max: Vec2::new(center.x + 2, center.y + 30).with_z(upper_alt + 10),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 2, center.y - 30).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 2, center.y + 30).with_z(upper_alt + 10),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();

        // Agent desk
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 9), 9.0, 6.0)
            .intersect(painter.aabb(Aabb {
                min: (Vec2::new(center.x + 2, center.y - 2)).with_z(upper_alt + 9),
                max: (Vec2::new(center.x + 40, center.y - 40)).with_z(upper_alt + 16),
            }))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(woodalt.clone());
        // carve out the middle
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 9), 9.0, 5.0)
            .intersect(painter.aabb(Aabb {
                min: (Vec2::new(center.x + 3, center.y - 3)).with_z(upper_alt + 9),
                max: (Vec2::new(center.x + 40, center.y - 40)).with_z(upper_alt + 15),
            }))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        // Desk radius
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 9), 9.0, 1.0)
            .intersect(painter.aabb(Aabb {
                min: (Vec2::new(center.x + 3, center.y - 3)).with_z(upper_alt + 9),
                max: (Vec2::new(center.x + 40, center.y - 40)).with_z(upper_alt + 11),
            }))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(woodalt.clone());
        // Clear inner floor
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 9), 8.0, 1.0)
            .intersect(painter.aabb(Aabb {
                min: (Vec2::new(center.x + 3, center.y - 3)).with_z(upper_alt + 9),
                max: (Vec2::new(center.x + 40, center.y - 40)).with_z(upper_alt + 11),
            }))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        // Clear extra wall extensions
        painter
            .line(
                Vec2::new(center.x + 2, center.y - 9).with_z(upper_alt + 9),
                Vec2::new(center.x + 2, center.y - 9).with_z(upper_alt + 16),
                0.5,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        painter
            .line(
                Vec2::new(center.x + 8, center.y - 3).with_z(upper_alt + 9),
                Vec2::new(center.x + 8, center.y - 3).with_z(upper_alt + 16),
                0.5,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();

        let foundation_radius: f32 = 17.0;

        // The rampart court is below the base except for a low stone wall at the top.
        // Build the low stone wall before the main column.
        painter
            .cylinder_with_radius(center.with_z(base - 1), foundation_radius, 2.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        painter
            .cylinder_with_radius(center.with_z(base - 1), foundation_radius - 1.0, 2.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();

        //lower doorway
        painter
            .cylinder_with_radius(
                Vec2::new(center.x - 1, center.y + 12).with_z(base - 5),
                4.5,
                7.0,
            )
            .rotate_about_min(Mat3::new(1, 0, 0, 0, 0, -1, 0, 1, 0))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());

        // The main dock structure is a brick column.

        //column
        painter
            .cylinder_with_radius(center.with_z(base), 6.0, 45.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());

        // ring at floor level outside the column
        painter
            .cylinder_with_radius(center.with_z(base + 35), 8.0, 2.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        // half ring with offset to exclude the agent area floor
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 9), 7.0, 1.0)
            .intersect(painter.aabb(Aabb {
                min: (Vec2::new(center.x + 2, center.y - 8)).with_z(upper_alt + 9),
                max: (Vec2::new(center.x - 8, center.y + 8)).with_z(upper_alt + 10),
            }))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        // line under doorway
        painter
            .line(
                Vec2::new(center.x + 6, center.y - 2).with_z(upper_alt + 9),
                Vec2::new(center.x + 6, center.y + 2).with_z(upper_alt + 9),
                0.5,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());

        //lower doorway cut
        painter
            .cylinder_with_radius(
                Vec2::new(center.x - 1, center.y + 12).with_z(base - 5),
                3.5,
                7.0,
            )
            .rotate_about_min(Mat3::new(1, 0, 0, 0, 0, -1, 0, 1, 0))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();

        // finally, clear the entire inside of the tower
        painter
            .cylinder_with_radius(center.with_z(base), 5.0, 45.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();

        // The top of the tower

        //cone
        painter
            .cone_with_radius(center.with_z(base + 45), 8.0, 18.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        //remove 1/4 cyl
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 1, center.y + 1).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 6, center.y + 6).with_z(upper_alt + 17),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x, center.y + 2).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 6, center.y + 7).with_z(upper_alt + 17),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        //platform cleanup
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 2, center.y - 15).with_z(upper_alt + 8),
                max: Vec2::new(center.x + 6, center.y + 9).with_z(upper_alt + 9),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());

        //upper door
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 5, center.y - 2).with_z(upper_alt + 10),
                max: Vec2::new(center.x + 7, center.y + 2).with_z(upper_alt + 13),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 5, center.y - 1).with_z(upper_alt + 10),
                max: Vec2::new(center.x + 7, center.y + 1).with_z(upper_alt + 15),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 5, center.y - 1).with_z(upper_alt + 10),
                max: Vec2::new(center.x + 7, center.y + 1).with_z(upper_alt + 13),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        //door sprites

        let door_rot = if self.rotation == 0.0 {
            (2, 6)
        } else if self.rotation == PI / 2.0 {
            (4, 0)
        } else if self.rotation == PI {
            (6, 2) //good
        } else {
            (0, 4)
        };
        let sprite_fill = Fill::Block(Block::air(SpriteKind::Door).with_ori(door_rot.0).unwrap());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x + 6, center.y - 1, upper_alt + 10),
                max: Vec3::new(center.x + 7, center.y + 0, upper_alt + 11),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        let sprite_fill = Fill::Block(Block::air(SpriteKind::Door).with_ori(door_rot.1).unwrap());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x + 6, center.y + 0, upper_alt + 10),
                max: Vec3::new(center.x + 7, center.y + 1, upper_alt + 11),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());

        //bracing diagonal bits
        painter
            .line(
                Vec2::new(center.x + 5, center.y - 3).with_z(upper_alt - 3),
                Vec2::new(center.x + 17, center.y - 3).with_z(upper_alt + 8),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .line(
                Vec2::new(center.x + 5, center.y + 2).with_z(upper_alt - 3),
                Vec2::new(center.x + 17, center.y + 2).with_z(upper_alt + 8),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        //
        painter
            .line(
                Vec2::new(center.x - 18, center.y - 3).with_z(upper_alt + 8),
                Vec2::new(center.x - 6, center.y - 3).with_z(upper_alt - 3),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .line(
                Vec2::new(center.x - 18, center.y + 2).with_z(upper_alt + 8),
                Vec2::new(center.x - 6, center.y + 2).with_z(upper_alt - 3),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        //
        painter
            .line(
                Vec2::new(center.x - 3, center.y - 18).with_z(upper_alt + 8),
                Vec2::new(center.x - 3, center.y - 6).with_z(upper_alt - 3),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .line(
                Vec2::new(center.x + 2, center.y - 18).with_z(upper_alt + 8),
                Vec2::new(center.x + 2, center.y - 6).with_z(upper_alt - 3),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        //
        painter
            .line(
                Vec2::new(center.x - 3, center.y + 5).with_z(upper_alt - 3),
                Vec2::new(center.x - 3, center.y + 17).with_z(upper_alt + 8),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .line(
                Vec2::new(center.x + 2, center.y + 5).with_z(upper_alt - 3),
                Vec2::new(center.x + 2, center.y + 17).with_z(upper_alt + 8),
                1.0,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());

        //stairs
        painter
            .cylinder_with_radius(center.with_z(upper_alt + 8), 5.0, 1.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();

        let stairs_clear1 = painter.cylinder_with_radius(center.with_z(base), 5.0, 38.0);

        painter
            .prim(Primitive::sampling(
                stairs_clear1,
                spiral_staircase(center.with_z(base + 3), 6.0, 0.5, 9.0),
            ))
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());

        //clean up interface at top
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 1, center.y + 3).with_z(upper_alt + 8),
                max: Vec2::new(center.x + 4, center.y + 5).with_z(upper_alt + 9),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(wood.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 0, center.y + 2).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 6, center.y + 7).with_z(upper_alt + 10),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 1, center.y + 3).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 6, center.y + 7).with_z(upper_alt + 10),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .clear();
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 0, center.y + 2).with_z(upper_alt + 9),
                max: Vec2::new(center.x + 1, center.y + 3).with_z(upper_alt + 17),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());

        let window_rot = if self.rotation == 0.0 || self.rotation == PI {
            (2, 4)
        } else {
            (4, 2)
        };
        let sprite_fill = Fill::Block(
            Block::air(SpriteKind::Window1)
                .with_ori(window_rot.0)
                .unwrap(),
        );
        //upper window
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 6, center.y - 1).with_z(upper_alt + 12),
                max: Vec2::new(center.x - 5, center.y + 1).with_z(upper_alt + 15),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());

        //lower windows
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 6, center.y - 1).with_z(base + 19),
                max: Vec2::new(center.x - 5, center.y + 1).with_z(base + 22),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 6, center.y - 1).with_z(base + 1),
                max: Vec2::new(center.x - 5, center.y + 1).with_z(base + 4),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 5, center.y - 1).with_z(base + 4),
                max: Vec2::new(center.x + 6, center.y + 1).with_z(base + 7),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 5, center.y - 1).with_z(base + 22),
                max: Vec2::new(center.x + 6, center.y + 1).with_z(base + 25),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x + 5, center.y - 1).with_z(base + 30),
                max: Vec2::new(center.x + 6, center.y + 1).with_z(base + 33),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());

        let sprite_fill = Fill::Block(
            Block::air(SpriteKind::Window1)
                .with_ori(window_rot.1)
                .unwrap(),
        );
        //side windows
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 1, center.y + 5).with_z(base + 17),
                max: Vec2::new(center.x + 1, center.y + 6).with_z(base + 20),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec2::new(center.x - 1, center.y - 6).with_z(base + 13),
                max: Vec2::new(center.x + 1, center.y - 5).with_z(base + 16),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());

        //lights
        painter.rotated_sprite(
            Vec2::new(center.x - 3, center.y + 5).with_z(base + 8),
            SpriteKind::WallLampSmall,
            4,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 2, center.y + 5).with_z(base + 8),
            SpriteKind::WallLampSmall,
            4,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 3, center.y + 5).with_z(base + 18),
            SpriteKind::WallLampSmall,
            4,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 2, center.y + 5).with_z(base + 18),
            SpriteKind::WallLampSmall,
            4,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 3, center.y - 6).with_z(base + 8),
            SpriteKind::WallLampSmall,
            0,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 2, center.y - 6).with_z(base + 8),
            SpriteKind::WallLampSmall,
            0,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 3, center.y - 6).with_z(base + 18),
            SpriteKind::WallLampSmall,
            0,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 2, center.y - 6).with_z(base + 18),
            SpriteKind::WallLampSmall,
            0,
        );

        painter.rotated_sprite(
            Vec2::new(center.x + 5, center.y - 3).with_z(base + 13),
            SpriteKind::WallLampSmall,
            2,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 5, center.y + 2).with_z(base + 13),
            SpriteKind::WallLampSmall,
            2,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 5, center.y - 3).with_z(base + 29),
            SpriteKind::WallLampSmall,
            2,
        );
        painter.rotated_sprite(
            Vec2::new(center.x + 5, center.y + 2).with_z(base + 29),
            SpriteKind::WallLampSmall,
            2,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 6, center.y - 3).with_z(base + 13),
            SpriteKind::WallLampSmall,
            6,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 6, center.y + 2).with_z(base + 13),
            SpriteKind::WallLampSmall,
            6,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 6, center.y - 3).with_z(base + 29),
            SpriteKind::WallLampSmall,
            6,
        );
        painter.rotated_sprite(
            Vec2::new(center.x - 6, center.y + 2).with_z(base + 29),
            SpriteKind::WallLampSmall,
            6,
        );
        //upper lighting
        for dir in DIAGONALS {
            let pos = (center + dir * 12).with_z(upper_alt + 7);
            painter.sprite(pos, SpriteKind::Lantern)
        }
        for dir in CARDINALS {
            let pos = (center + dir * 24).with_z(upper_alt + 7);
            painter.sprite(pos, SpriteKind::Lantern)
        }
        let sprite_fill = Fill::Block(Block::air(SpriteKind::Lantern).with_ori(2).unwrap());
        //on cone lamps
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 6, center.y + 5, upper_alt + 16),
                max: Vec3::new(center.x - 5, center.y + 6, upper_alt + 17),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x + 5, center.y + 5, upper_alt + 16),
                max: Vec3::new(center.x + 6, center.y + 6, upper_alt + 17),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 6, center.y - 6, upper_alt + 16),
                max: Vec3::new(center.x - 5, center.y - 5, upper_alt + 17),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());

        // laterns on walls of agent desk
        let agent_lamp1_ori = (((self.rotation / std::f32::consts::FRAC_PI_2) as u8 * 2) + 6) % 8;
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x + 7, center.y - 3, upper_alt + 13),
                max: Vec3::new(center.x + 8, center.y - 4, upper_alt + 14),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(Fill::Block(
                Block::air(SpriteKind::LanternAirshipWallBrownS)
                    .with_ori(agent_lamp1_ori)
                    .unwrap(),
            ));
        let agent_lamp2_ori = (self.rotation / std::f32::consts::FRAC_PI_2) as u8 * 2;
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x + 3, center.y - 7, upper_alt + 13),
                max: Vec3::new(center.x + 4, center.y - 8, upper_alt + 14),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(Fill::Block(
                Block::air(SpriteKind::LanternAirshipWallBrownS)
                    .with_ori(agent_lamp2_ori)
                    .unwrap(),
            ));

        //interior

        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 2, center.y - 3, base + 6),
                max: Vec3::new(center.x - 1, center.y + -2, base + 7),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 2, center.y - 3, base + 15),
                max: Vec3::new(center.x - 1, center.y + -2, base + 16),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 2, center.y - 3, base + 24),
                max: Vec3::new(center.x - 1, center.y + -2, base + 25),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 2, center.y - 3, base + 33),
                max: Vec3::new(center.x - 1, center.y + -2, base + 34),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());
        painter
            .aabb(Aabb {
                min: Vec3::new(center.x - 2, center.y - 3, base + 44),
                max: Vec3::new(center.x - 1, center.y + -2, base + 45),
            })
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(sprite_fill.clone());

        // crate and barrel sprites
        let mut sprite_positions = vec![];
        for a in 0..5 {
            sprite_positions.push(Vec2::new(center.x + 1 + a, center.y + 2));
        }
        for b in 0..=1 {
            sprite_positions.push(Vec2::new(center.x, center.y + 3 + b));
        }
        for sprite_pos in sprite_positions {
            let rows = (RandomField::new(0).get(sprite_pos.with_z(base)) % 3) as i32;
            for r in 0..rows {
                painter
                    .aabb(Aabb {
                        min: sprite_pos.with_z(upper_alt + 10 + r),
                        max: (sprite_pos + 1).with_z(upper_alt + 11 + r),
                    })
                    .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
                    .fill(Fill::Block(Block::air(
                        match (RandomField::new(0).get(sprite_pos.with_z(base + r)) % 2) as i32 {
                            0 => SpriteKind::Barrel,
                            _ => SpriteKind::CrateBlock,
                        },
                    )));
            }
        }

        // campfire
        painter.spawn(
            EntityInfo::at(self.campfire_pos.map(|e| e as f32 + 0.5))
                .into_special(SpecialEntity::Waypoint),
        );

        // Rampart
        painter
            .cylinder_with_radius(center.with_z(base - 1), foundation_radius - 1.0, 1.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(grass.clone());
        painter
            .cylinder_with_radius(center.with_z(base - 1), 10.0, 1.0)
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(brick.clone());

        painter
            .cylinder_with_radius(
                center.with_z(min_foundation_alt),
                foundation_radius,
                (base - min_foundation_alt - 1) as f32,
            )
            .rotate_about(Mat3::rotation_z(self.rotation).as_(), center.with_z(base))
            .fill(dirt.clone());

        let stair_height = 8;
        let stair_width = 3;
        let stair_levels = (base - min_foundation_alt - 1) / (stair_height + 1);
        let stair_drop = 4;
        let stair_landing_space = stair_height + 3;
        let stairtop = base - 1;
        /*
           Rampart stair components

           ┌────┐
           │ SL │
           ├────┼┐
           │    │ ┐
           │ SC │  ┐
           │    │   ┐
           │    │ S  ┐
           │    ├─────┬────┐
           │    │  MD │ SL │
           │    │     ├────┤
           └────┼─────┤    │
                └  S  │ SC │
                 └    │    │
                  └   │    │
                   └  │    │
                    └ └────┘
           S - Stair
           MD - Middle Dirt
           SL - Stair Landing
           SC - Stair Column

           The diagram shows a stair section for an even-numbered level;
           odd-numbered levels are mirrored left-to-right.
           The staircase has a cap made of brick and the stair sides are dirt.
           The stair cap is not shown in the diagram.
           The above components are rendered for each level of the stairs,
           and flipped back and forth for as many levels as will fit in the
           rampart height.
           These components are reused, rotated, and translated to build the full staircase.
        */
        let edge_clear = aabb(
            Vec2::new(center.x - 4, center.y + foundation_radius as i32 - 1)
                .with_z(min_foundation_alt),
            Vec2::new(center.x + 4, center.y + foundation_radius as i32).with_z(base + 1),
        );
        let edge_fill = aabb(
            Vec2::new(center.x - 7, center.y + foundation_radius as i32 - 2).with_z(stairtop),
            Vec2::new(center.x + 6, center.y + foundation_radius as i32 - 2).with_z(stairtop),
        );
        let stair = aabb(
            Vec2::new(center.x - 4, center.y + foundation_radius as i32 - 1)
                .with_z(stairtop - stair_height),
            Vec2::new(
                center.x + 3,
                center.y + foundation_radius as i32 + stair_width - 2,
            )
            .with_z(stairtop - 1),
        );
        let middirt = aabb(
            Vec2::new(center.x - 4, center.y + foundation_radius as i32 - 1)
                .with_z(stairtop - stair_height - 1),
            Vec2::new(
                center.x + 3,
                center.y + foundation_radius as i32 + stair_width - 2,
            )
            .with_z(stairtop - stair_height - (stair_drop + 1)),
        );
        let stair_landing = aabb(
            Vec2::new(center.x + 6, center.y + foundation_radius as i32 - 1).with_z(stairtop),
            Vec2::new(
                center.x + 4,
                center.y + foundation_radius as i32 + stair_width - 2,
            )
            .with_z(stairtop),
        );
        let stair_column = aabb(
            Vec2::new(center.x + 6, center.y + foundation_radius as i32 - 1).with_z(stairtop - 1),
            Vec2::new(
                center.x + 4,
                center.y + foundation_radius as i32 + stair_width - 2,
            )
            .with_z(stairtop - (stair_height + stair_drop)),
        );

        let slice = painter.aabb(edge_clear);
        let edge = painter.aabb(edge_fill);
        let stair_cap_even =
            painter
                .ramp(stair, Dir::X)
                .intersect(painter.ramp(stair, Dir::X).rotate_about(
                    Mat3::new(-1, 0, 0, 0, 1, 0, 0, 0, -1),
                    center.with_z(stairtop - 4),
                ));
        let stair_cap_odd =
            stair_cap_even.rotate_about(Mat3::new(-1, 0, 0, 0, -1, 0, 0, 0, 1), stair.center());
        let stair_base_even = painter
            .ramp(stair, Dir::X)
            .intersect(painter.ramp(stair, Dir::X).translate(Vec3::new(1, 0, 0)))
            .union(painter.aabb(middirt))
            .union(
                painter
                    .ramp(stair, Dir::X)
                    .rotate_about(
                        Mat3::new(-1, 0, 0, 0, 1, 0, 0, 0, -1),
                        center.with_z(stairtop - 4),
                    )
                    .translate(Vec3::new(0, 0, -(stair_height + stair_drop))),
            );
        let stair_base_odd =
            stair_base_even.rotate_about(Mat3::new(-1, 0, 0, 0, -1, 0, 0, 0, 1), stair.center());
        let stair_column_cap = painter.aabb(stair_landing);
        let stair_column_base = painter.aabb(stair_column);

        // for each side of the rampart
        for side in 0..4 {
            let rot: f32 = (self.rotation + side as f32 * std::f32::consts::FRAC_PI_2)
                .rem_euclid(std::f32::consts::TAU);

            // Flatten the rampart cylinder where the stairs will go
            painter.fill(
                slice.rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                Fill::Block(Block::empty()),
            );
            painter.fill(
                edge.rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                brick.clone(),
            );
            painter.fill(
                edge.translate(Vec3::new(0, 0, 1))
                    .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                Fill::Block(Block::empty()),
            );
            // The edge near the stairs is filled in with bricks and gaps at the edge of the
            // stair wall that was removed.
            let picketx = 3;
            for i in 0..3 {
                painter
                    .line(
                        Vec2::new(
                            center.x + picketx - i * 4,
                            center.y + foundation_radius as i32 - 2,
                        )
                        .with_z(base),
                        Vec2::new(
                            center.x + picketx - i * 4 - 2,
                            center.y + foundation_radius as i32 - 2,
                        )
                        .with_z(base),
                        0.5,
                    )
                    .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base))
                    .fill(brick.clone());
            }
            painter
                .aabb(aabb(
                    Vec2::new(center.x + 4, center.y + 4).with_z(base - 1),
                    Vec2::new(center.x + 6, center.y + foundation_radius as i32 - 2)
                        .with_z(base - 1),
                ))
                .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base))
                .fill(brick.clone());

            // if no stairs, just fill in around the rampart top with dirt
            if stair_levels == 0 {
                painter
                    .aabb(aabb(
                        Vec2::new(center.x - 4, center.y + foundation_radius as i32 - 1)
                            .with_z(base - 7),
                        Vec2::new(center.x + 4, center.y + foundation_radius as i32)
                            .with_z(base - 2),
                    ))
                    .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base))
                    .fill(dirt.clone());
                continue;
            }

            // for each level of stairs
            for level in 0..stair_levels {
                let y_off = level % 2 * stair_width;
                let stair_y_off = if level % 2 > 0 && stair_width % 2 > 0 {
                    y_off + 1
                } else {
                    y_off
                };
                if level % 2 == 0 {
                    painter.fill(
                        stair_cap_even
                            .translate(Vec3::new(0, stair_y_off, level * -(stair_height + 1)))
                            .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                        brick.clone(),
                    );
                    painter.fill(
                        stair_base_even
                            .translate(Vec3::new(0, stair_y_off, level * -(stair_height + 1)))
                            .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                        dirt.clone(),
                    );
                } else {
                    painter.fill(
                        stair_cap_odd
                            .translate(Vec3::new(0, stair_y_off, level * -(stair_height + 1)))
                            .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                        brick.clone(),
                    );
                    painter.fill(
                        stair_base_odd
                            .translate(Vec3::new(0, stair_y_off, level * -(stair_height + 1)))
                            .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                        dirt.clone(),
                    );
                }
                painter.fill(
                    stair_column_cap
                        .translate(Vec3::new(
                            level % 2 * -stair_landing_space,
                            y_off,
                            level * -(stair_height + 1),
                        ))
                        .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                    brick.clone(),
                );
                painter.fill(
                    stair_column_base
                        .translate(Vec3::new(
                            level % 2 * -stair_landing_space,
                            y_off,
                            level * -(stair_height + 1),
                        ))
                        .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                    dirt.clone(),
                );
                painter.fill(
                    stair_column_cap
                        .translate(Vec3::new(
                            (level + 1) % 2 * -stair_landing_space,
                            y_off,
                            (level + 1) * -(stair_height + 1),
                        ))
                        .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                    brick.clone(),
                );
                painter.fill(
                    stair_column_base
                        .translate(Vec3::new(
                            (level + 1) % 2 * -stair_landing_space,
                            y_off,
                            (level + 1) * -(stair_height + 1),
                        ))
                        .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base)),
                    dirt.clone(),
                );
                let lamp_pos = Vec2::new(
                    center.x - 5 + level % 2 * (stair_height + 1),
                    center.y + foundation_radius as i32 - 1,
                )
                .with_z(base - 5 - level * (stair_height + 1));
                let lamp_ori = (((rot / std::f32::consts::FRAC_PI_2) as u8 * 2) + 10) % 8;
                painter
                    .aabb(aabb(lamp_pos, lamp_pos))
                    .rotate_about(Mat3::rotation_z(rot).as_(), center.with_z(base))
                    .fill(Fill::sprite_ori(
                        SpriteKind::LanternAirshipWallBrownS,
                        lamp_ori,
                    ));
            }
        }
    }
}

fn aabb(min: Vec3<i32>, max: Vec3<i32>) -> Aabb<i32> {
    let aabb = Aabb { min, max }.made_valid();
    Aabb {
        min: aabb.min,
        max: aabb.max + 1,
    }
}
